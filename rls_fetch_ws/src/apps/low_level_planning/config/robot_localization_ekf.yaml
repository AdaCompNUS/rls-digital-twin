# EKF Configuration for robot_localization package
# This node fuses odometry and IMU data to provide better localization

# The frequency at which the filter will output a position estimate. Note that the filter will not begin
# computation until it receives at least one message from one of the inputs. It will then run continuously at the
# frequency specified here, regardless of whether it receives more measurements.
frequency: 30

# The period, in seconds, after which we consider a sensor to have timed out. In this event, we carry out a predict
# cycle on the EKF without a correction step. This parameter can be thought of as the minimum frequency at which the
# filter will generate new output. If any sensor data is received within this time period, the filter will run at the
# rate specified by the 'frequency' parameter.
sensor_timeout: 0.1

# If this is set to true, no 3D information will be used in your state estimate. Use this if you are operating in a 
# planar environment and want to ignore the effect of small variations in the ground plane that might otherwise be
# detected by, for example, an IMU.
two_d_mode: true

# Use this parameter to provide an offset to the transform generated by ekf_localization_node. This can be used for
# future dating the transform, which is required for some use cases, such as particle filters.
transform_time_offset: 0.0

# Use this parameter to provide specify how long the tf listener should wait for a transform to become available. 
# The default value is zero, which means it will return immediately.
transform_timeout: 0.0

# If you're having trouble, try setting this to true, and then echo the /diagnostics_agg topic to see if the node is
# unhappy with any of your data.
print_diagnostics: true

# Debug settings. Not for the faint of heart. Outputs a ludicrous amount of information to the file specified by
# debug_out_file. The link from sensor data to measurement is not always obvious, so the debug log helps you understand
# which sensor measurements are treated as which state variables. This should only be used when you have a specific problem
# with your state estimator and need to troubleshoot. The data written to the file is in state estimation units.
debug: false
debug_out_file: /tmp/debug_ekf_localization.txt

# Defaults to "robot_localization_estimator_node" if unspecified
map_frame: map              # Defaults to "map" if unspecified
odom_frame: odom            # Defaults to "odom" if unspecified  
base_link_frame: base_link  # Defaults to "base_link" if unspecified
world_frame: odom           # Defaults to the value of odom_frame if unspecified

# The filter accepts an arbitrary number of inputs from each input message type (Odometry, PoseStamped,
# TwistStamped, Imu). To add a new one, simply append the next number in the sequence to its base name,
# e.g., odom0, odom1, twist0, twist1, imu0, imu1, imu2, etc. The value should be the topic name. These
# parameters obviously have no default values, and must be specified.

# Odometry from wheel encoders
odom0: /odom

# For each sensor, we need to specify which variables in its respective message we want to
# include in the state. The order of the variables for each message type is:
#
# For Odometry messages:
# (x, y, z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw)
#
# For Imu messages:
# (x, y, z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az)

# Configuration for wheel odometry (odom0)
# We trust the x, y position and yaw from wheel odometry
# We also use the linear and angular velocities
odom0_config: [true,  true,  false,
               false, false, true,
               true,  true,  false,
               false, false, true,
               false, false, false]

# If the data is subject to outliers, use these threshold settings, expressed as Mahalanobis distances, to control
# how far away from the current vehicle state a sensor measurement is allowed to be. Each defaults to
# numeric_limits<double>::max() if unspecified. It is strongly recommended that these parameters be removed if the
# data is trustworthy.
odom0_differential: false

# If we're including accelerations in our state estimate, then we can also include acceleration data from our
# IMU sensor.
odom0_relative: false

# Each sensor reading updates some or all of the filter's state. These options give you greater control over
# which values from each measurement are fed to the filter. For example, if you have an odometry message as input,
# but only want to use its Z position value, then set the entire vector to false, except for the third entry.
# In the case of messages that have both a pose and a twist, the filter will use a value if its respective
# configuration is set to true.

# Configuration for IMU data (when available on real robot)
# We'll use angular velocity (yaw rate) and linear acceleration from IMU
imu0: /imu/data
imu0_config: [false, false, false,
              false, false, false, 
              false, false, false,
              false, false, true,
              true,  true,  false]

# The differential setting controls whether we integrate the raw measurement or the difference between this measurement
# and the previous measurement. There are only two cases where you want to set this to true: (1) for odometry data
# that is provided by a robot_localization state estimation node on another robot, and (2) for wheel encoder data that
# is cumulative, and is *not* already processed by a robot_localization state estimation node.
imu0_differential: false

# When measuring the pose of sensors, it's important to note that many frame_id values
# automatically assume the base_link frame_id.
imu0_relative: false

# If your data is subject to outliers, use these threshold settings, expressed as Mahalanobis distances, to control
# how far away from the current vehicle state a sensor measurement is allowed to be. Each defaults to
# numeric_limits<double>::max() if unspecified.
imu0_remove_gravitational_acceleration: true

# [ADVANCED] Some IMUs automatically remove acceleration due to gravity, and others don't. If yours doesn't, please set
# this to true, and *make sure* your data conforms to REP-103, specifically, that the data is in ENU frame.
imu0_linear_acceleration_rejection_threshold: 0.8

# [ADVANCED] When the node starts, if this parameter is true, then the first measurement is treated as a "zero point"
# for all future measurements. While you can achieve the same effect with the differential paremeter, the key
# difference is that the relative parameter doesn't cause the measurement to be converted to a velocity before
# integrating it. If you simply want your measurements to start at 0 for a given sensor, set this to true.
imu0_angular_velocity_rejection_threshold: 1.57

# [ADVANCED] This represents the initial value for the named state variable.
# initial_state: [0.0, 0.0, 0.0,
#                 0.0, 0.0, 0.0,
#                 0.0, 0.0, 0.0,
#                 0.0, 0.0, 0.0,
#                 0.0, 0.0, 0.0]

# [ADVANCED] This represents the initial value for the named state variable's covariance. 
# The state vector is:
# [x, y, z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az]
# The initial covariance matrix can be set as follows:
# initial_estimate_covariance: [1e-9,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
#                                  0, 1e-9,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
#                                  0,    0, 1e-9,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
#                                  0,    0,    0, 1e-9,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
#                                  0,    0,    0,    0, 1e-9,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
#                                  0,    0,    0,    0,    0, 1e-9,    0,    0,    0,    0,     0,     0,     0,    0,    0,
#                                  0,    0,    0,    0,    0,    0, 1e-9,    0,    0,    0,     0,     0,     0,    0,    0,
#                                  0,    0,    0,    0,    0,    0,    0, 1e-9,    0,    0,     0,     0,     0,    0,    0,
#                                  0,    0,    0,    0,    0,    0,    0,     0,     0.04, 0,    0,    0,    0,    0,    0,
#                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0.01, 0,    0,    0,    0,    0,
#                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0.01, 0,    0,    0,    0,
#                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0.02, 0,    0,    0,
#                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0.01, 0,    0,
#                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0.01, 0,
#                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0.015]

# [ADVANCED] This matrix represents the process noise covariance matrix. This will control how the filter respects
# predictions vs. measurements. Setting the values in the Q matrix to smaller values will make the filter trust the
# process model (prediction) more, while larger values make the filter trust the measurements more.
# The state vector is:
# [x, y, z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az]
process_noise_covariance: [0.05, 0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0.05, 0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0.06, 0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0.03, 0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0.03, 0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0.06, 0,     0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0.025, 0,     0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0.025, 0,    0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0.04, 0,    0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0.01, 0,    0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0.01, 0,    0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0.02, 0,    0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0.01, 0,    0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0.01, 0,
                           0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0.015] 